import os
import re

# ver p3.py nu  keine ahnung ob correct  
# --- Globale Konfiguration ---
AI_ID = 2
SCRIPT_NAME = f"p{AI_ID}.py"
INFILE = "Gtst.htm"
OUTFILE = f"P{AI_ID}.htm"

# Debug-Schalter. Setze auf True für detaillierte Ausgaben, sonst False.
DEBUG = True

# --- Konfiguration der Parser-Regeln ---
DELIMITERS = ['.', ',', '|']
VALID_STEPS = {'step2': 2, 'step4': 4, 'step5': 5, 'step8': 8, 'step10': 10, 'step16': 16}
DEFAULT_STEP = 5

def parse_config_file():
    try:
        with open(INFILE, "r", encoding="utf-8") as f:
            lines = f.readlines()
    except FileNotFoundError:
        print(f"FEHLER: Eingabedatei '{INFILE}' nicht gefunden.")
        return []

    output_array = []
    step = DEFAULT_STEP
    step_is_finalized = False
    last_idx = -1
    delimiter_class = '[' + re.escape(''.join(DELIMITERS)) + ']'

    if DEBUG: print(f"--- Starte Verarbeitung von {INFILE} mit {len(lines)} Zeilen ---")

    for line_num, original_line in enumerate(lines):
        line = original_line.strip()
        if not line:
            continue

        if line.startswith('//'):
            pattern = r'^\/\/\s*\d+\s*' + delimiter_class
            if not re.match(pattern, line):
                if DEBUG: print(f"Zeile {line_num+1}: Ignoriert (reiner Kommentar). Inhalt: '{line}'")
                continue

        delimiter, d_pos = None, -1
        match = re.search(delimiter_class, line[:20])
        if match:
            delimiter = match.group(0)
            d_pos = match.start()
        else:
            if DEBUG: print(f"Zeile {line_num+1}: Übersprungen (kein Trennzeichen gefunden). Inhalt: '{line}'")
            continue

        head = line[:d_pos]
        content = line[d_pos + 1:]
        idx_str = "".join(filter(str.isdigit, head))

        if idx_str:
            idx = int(idx_str)
        else:
            idx = last_idx + 1
            if DEBUG: print(f"Zeile {line_num+1}: Keinen Index gefunden, generiere nächsten Index: {idx}")
        last_idx = idx

        if idx == 0 and not step_is_finalized:
            found_step_in_line = False
            for key, val in VALID_STEPS.items():
                if key in original_line:
                    step = val
                    print(f"Info: Step-Größe wurde aus Zeile {line_num+1} auf {step} gesetzt (Schlüsselwort '{key}' gefunden).")
                    found_step_in_line = True
                    break
            if not found_step_in_line and DEBUG:
                print(f"Warnung: In Zeile mit Index 0 wurde kein 'stepX' gefunden. Benutze Standard-Step: {step}.")
            step_is_finalized = True

        values = [p.strip() for p in content.split(delimiter)]

        if len(values) > step:
            if DEBUG: print(f"Zeile {line_num+1}: Kürze Werte von {len(values)} auf {step}.")
            values = values[:step]
        elif len(values) < step:
            values.extend([''] * (step - len(values)))

        start_pos = idx * step
        required_size = start_pos + step
        if len(output_array) < required_size:
            output_array.extend([''] * (required_size - len(output_array)))
        output_array[start_pos : start_pos + step] = values

        if DEBUG:
            print(f"Zeile {line_num+1}: Verarbeitet -> Index={idx}, Trennzeichen='{delimiter}', Werte={values} -> Positionen {start_pos}-{start_pos + step - 1}")

    return output_array, step
    # return output_array

def write_output_file(data):
    if not data:
        print("Warnung: Keine Daten zum Schreiben vorhanden.")
        return
    try:
        with open(OUTFILE, "w", encoding="utf-8") as f:
            # f.write(f"// Generated by {SCRIPT_NAME} (AI_ID: {AI_ID})  \n")
            # f.write(f"// Total elements: {len(data)} \n")
            for i, value in enumerate(data):
                f.write(f"{i} {value}\n")
        print(f"\n✓ ERFOLG: {len(data)} Elemente wurden in '{OUTFILE}' geschrieben.")
    except IOError as e:
        print(f"\nFEHLER: Schreiben der Datei '{OUTFILE}' fehlgeschlagen: {e}")

if __name__ == '__main__':
    print(f"--- Führe {SCRIPT_NAME} aus ---")
    if not os.path.exists(INFILE):
        print(f"Info: Eingabedatei '{INFILE}' nicht gefunden. Erstelle sie mit Testinhalt.")
        test_content="""
        
# <pre>
// ---  SAVED CONFIG   ---  0 | step5 | 5 | | | 
// lines mit (1)comment werden nur weiter geparst geprueft wenn : (2)index number direct nach (3)comment AND  dann (4)delimiter   AND  dann (5)key 
// kein index direct nach comment ignore line
// ID | not_valid_line_key     kein index direct nach comment ignore line
// ID   | KEY         | val1   | KEY2   | KEY3  |  KEY4 
// ID   | KEY         | val1   | val2   | val3  |  val4 
0 | step | step5      |  5     |0       |0      |0|0|0|    easy: 0,step ,step5 ,,,,
-->1     | range_user5 | 31-99  |1       |1      |1  | 1 | <!--      
<!--2    , c_bg_10       ,#320a2b ,Color    , 2    ,2,2,2,2,2,
-->3     | dbgg15       | 1      | c_fg    | #cccccc | Color  | 3  |3 | 3 | 3 | 3  | | | | 5 comment /***/
/* 4.      c_btn20      .#3e3e42 .Color    . 4    .4.4.4.4.4.4.4.
,key_ohne_index ohne comment25 , Segoe UI , Font , -   , index 5*5= 25 wird fuer key berechnet    comment /***/
# 6.key6__30__  .6.6.6.6.6.6.6.6.....
//,key7,,,7,7,,,7,7,7,,,    must ignore , kein index   direct nach comment
  ,key8__35__ , ,7  ,7,7,7,7,,,,    ok index next(6+1)*5 fuer key8 is number t weil 7 wurde comment wird berechnet
 10 . key_10__50__ . value_key_10   . key_10_2_value_10_2  . key_10_3_value_10_3 .  key_10_4_value_10_4 . "key_10_5_value_10_5   10_5 not used"


            """
        with open(INFILE, "w", encoding="utf-8") as f:
            f.write(test_content)
    result_array = parse_config_file()
    #
    #   out result_array
    #
    write_output_file(result_array)
    print(f"--- {SCRIPT_NAME} beendet ---")

'''
def parse_config_file():
    """
    Liest und verarbeitet die Konfigurationsdatei Gtst.htm und schreibt das Ergebnis
    in eine 1D-Array-Struktur in die Ausgabedatei G2.htm.
    
    Inklusive der Regel für die Behandlung von Kommentarzeilen.
    """ [T9](1)

def write_output_file(data):
    """Schreibt das 1D-Array in die Zieldatei.""" [T12](2)
    
    
    
    
    
    
    In your p2.py script, change the very last line of the parse_config_file function.


Change this:


python
# In p2.py, inside parse_config_file()
    return output_array

To this:


python
# In p2.py, inside parse_config_file()
    return output_array, step
    
    
'''
