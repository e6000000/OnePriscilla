


--in---
 # <pre>
// ---  SAVED CONFIG   ---  0 | step5 | 5 | | | 
// lines mit (1)comment werden nur weiter geparst geprueft wenn : (2)index number direct nach (3)comment AND  dann (4)delimiter   AND  dann (5)key 
// kein index direct nach comment ignore line
// ID | not_valid_line_key     kein index direct nach comment ignore line
// ID   | KEY         | val1   | KEY2   | KEY3  |  KEY4 
// ID   | KEY         | val1   | val2   | val3  |  val4 
0 | step | step5      |  5     |0       |0      |0|0|0|    easy: 0,step ,step5 ,,,,
-->1     | range_user5 | 31-99  |1       |1      |1  | 1 | <!--      
<!--2    , c_bg       ,#320a2b ,Color    , 2    ,2,2,2,2,2,
-->3     | dbgg15       | 1      | c_fg    | #cccccc | Color  | 3  |3 | 3 | 3 | 3  | | | | 5 comment /*
/**/4.      c_btn20      .#3e3e42 .Color    . 4    .4.4.4.4.4.4.4.
,key_ohne_index ohne comment25 , Segoe UI , Font , -   , index 5*5= 25 wird fuer key berechnet 
# 6.key6__30__  .6.6.6.6.6.6.6.6.....
//,key7,,,7,7,,,7,7,7,,,    must ignore , kein index   direct nach comment
  ,key8__35__ , ,7  ,7,7,7,7,,,,    ok index next(6+1)*5 fuer key8 is number t weil 7 wurde comment wird berechnet
 10 . key_10__50__ . value_key_10   . key_10_2_value_10_2  . key_10_3_value_10_3 .  key_10_4_value_10_4 . "key_10_5_value_10_5   10_5 not used"





-- out-----

0 step
1 step5
2 5
3 0
4 0
5 range_user5
6 31-99
7 1
8 1
9 1
10 c_bg
11 #320a2b
12 Color
13 2
14 2
15 dbgg15
16 1
17 c_fg
18 #cccccc
19 Color
20 key_ohne_index ohne comment25
21 Segoe UI
22 Font
23 -
24 index 5*5= 25 wird fuer key berechnet
25 
26 
27 
28 
29 
30 key6__30__
31 6
32 6
33 6
34 6
35 key8__35__
36 
37 7
38 7
39 7
40 
41 
42 
43 
44 
45 
46 
47 
48 
49 
50 key_10__50__
51 value_key_10
52 key_10_2_value_10_2
53 key_10_3_value_10_3
54 key_10_4_value_10_4






##################################################################
--p4.py ------------------------------------------


import os

# --- Global Configuration AI is Claude id 4 ---
AI_ID = 4
SCRIPT_NAME = f"p{AI_ID}.py"
INFILE = "Gtst.htm"
OUTFILE = f"G{AI_ID}.htm"

debgg = 1  # Debug mode: 1 = on, 0 = off


def parse_config():
    """
    Parses config file into 1D array structure.
    
    Rules:
    1. Search for "stepX" keyword to determine step size
    2. Index 0 is treated like any other index (no special handling)
    3. Key name before delimiter can be anything
    4. Comment lines: Only parse if index number DIRECTLY after comment opener
       Examples:
       - <!--2-->|key|value  → VALID (index 2 directly after <!--)
       - //7,key,value       → INVALID (no index directly after //)
       - -->1|key|value      → VALID (index 1 directly after -->)
    """
    # --- Initialization ---
    DELIMITERS = ['.', ',', '|', ';']
    VALID_STEPS = {'step2': 2, 'step4': 4, 'step5': 5, 'step8': 8, 'step10': 10, 'step16': 16}
    COMMENT_MARKERS = ['<!--', '-->', '//', '/*', '*/']
    
    try:
        with open(INFILE, "r", encoding="utf-8") as f:
            lines = f.readlines()
    except FileNotFoundError:
        print(f"ERROR: Input file '{INFILE}' not found.")
        return

    out_arr = []
    step = 5  # Default
    step_found = False
    last_idx = -1

    print(f"--- Processing {len(lines)} lines ---")

    # --- Main Loop ---
    for line_num, line in enumerate(lines, 1):
        line = line.strip()
        
        if not line:
            continue

        # --- Comment Handling ---
        is_comment = False
        work_line = line
        
        # Check for any comment marker at start
        for marker in COMMENT_MARKERS:
            if line.startswith(marker):
                is_comment = True
                # Remove comment marker
                work_line = line[len(marker):].strip()
                
                # Check if index number is DIRECTLY after comment marker
                if not work_line or not work_line[0].isdigit():
                    if debgg:
                        print(f"Line {line_num}: Skipped (comment '{marker}' without direct index number)")
                    work_line = None
                    break
                
                if debgg:
                    print(f"Line {line_num}: Valid comment with '{marker}' + index")
                break
        
        # Skip if comment was invalid
        if work_line is None:
            continue

        # Find first delimiter
        d_pos = -1
        delimiter = None
        for i, char in enumerate(work_line[:20]):
            if char in DELIMITERS:
                d_pos = i
                delimiter = char
                break
        
        if d_pos == -1:
            if debgg:
                print(f"Line {line_num}: Skipped (no delimiter)")
            continue

        head = work_line[:d_pos]
        content_str = work_line[d_pos + 1:]
        
        # --- Parse Index ---
        idx_digits = "".join(filter(str.isdigit, head))
        
        if idx_digits:
            idx = int(idx_digits)
        else:
            idx = last_idx + 1
            if debgg:
                print(f"Line {line_num}: Generated index {idx}")
        
        last_idx = idx

        # --- Step Size Detection: Search for "stepX" keyword ---
        if not step_found:
            line_lower = line.lower()
            for step_keyword, step_value in VALID_STEPS.items():
                if step_keyword in line_lower:
                    step = step_value
                    step_found = True
                    print(f"INFO: Step size set to {step} (found '{step_keyword}' in line {line_num})")
                    break

        # --- Parse Values ---
        values = [v.strip() for v in content_str.split(delimiter)]
        
        # Remove empty trailing values
        while len(values) > 0 and values[-1] == '':
            values.pop()

        # --- Normalize to Step Size ---
        if len(values) > step:
            if debgg:
                print(f"Line {line_num}: Truncating {len(values)} to {step}")
            values = values[:step]
        elif len(values) < step:
            values.extend([''] * (step - len(values)))

        # --- Insert into 1D Array ---
        start_pos = idx * step
        required_size = start_pos + step

        if len(out_arr) < required_size:
            out_arr.extend([''] * (required_size - len(out_arr)))
        
        for i, value in enumerate(values):
            out_arr[start_pos + i] = value
        
        comment_flag = " [COMMENT]" if is_comment else ""
        if debgg:
            print(f"Line {line_num}{comment_flag}: idx={idx}, delim='{delimiter}', {len(values)} values → pos {start_pos}-{start_pos+step-1}")

    # --- Write Output ---
    try:
        with open(OUTFILE, "w", encoding="utf-8") as f:
            for i, value in enumerate(out_arr):
                f.write(f"{i} {value}\n")
        
        print(f"\n✓ SUCCESS: {len(out_arr)} elements written to '{OUTFILE}'")
        print(f"  Step size: {step}")
        print(f"  Debug mode: {'ON' if debgg else 'OFF'}")
        
    except IOError as e:
        print(f"ERROR: Write failed: {e}")


# --- Test File Creator ---
def create_test_file():
    """Creates test input matching your configuration"""
    test_content = """0 | step | step5      |  5     |0       |0      |0|0|0|
-->1     | range_user | 31-99  |1       |1      |1  | 1 |
<!--2    , c_bg       ,#320a2b ,Color    , 2    ,2,2,2,2,2,
-->3     | dbgg       | 1      | c_fg    | #cccccc | Color  | 3  |3 | 3 | 3 | 3  | | | | 5 comment /*
/**/4.      c_btn      .#3e3e42 .Color    . 4    .4.4.4.4.4.4.4.
,key_ohne_index ohne comment, Segoe UI , Font , -   , index 5*5= 25 wird fuer key berechnet 
; 6.key6  .6.6.6.6.6.6.6.6.....
//,key7,,,7,7,,,7,7,7,,,
  ,key8 , ,8  ,8,8,8,8,,,,
 10 . key_10 . value_key_10   . key_10_2_value_10_2  . key_10_3_value_10_3 .  key_10_4_value_10_4 . "key_10_5_value_10_5   10_5 not used"
"""
    
    with open(INFILE, "w", encoding="utf-8") as f:
        f.write(test_content)
    print(f"Test file '{INFILE}' created with your configuration")


# --- Main ---
if __name__ == '__main__':
    print(f"--- Running {SCRIPT_NAME} (AI_ID={AI_ID}) ---")
    
    if not os.path.exists(INFILE):
        print(f"Creating test file...")
        create_test_file()
    
    parse_config()
    print("--- Finished ---")



##################################################################
### p2.py ------------------------------------------------------------


 import os
import re

# --- Globale Konfiguration ---
AI_ID = 2
SCRIPT_NAME = f"p{AI_ID}.py"
INFILE = "Gtst.htm"
OUTFILE = f"G{AI_ID}.htm"

# NEU: Debug-Schalter. Setze auf True für detaillierte Ausgaben, sonst False.
DEBUG = True

# --- Konfiguration der Parser-Regeln ---
# Regel 1: Gültige Trennzeichen
DELIMITERS = ['.', ',', '|', ';']
# Regel 2: Gültige Step-Größen, die in Zeile mit Index 0 gesucht werden
VALID_STEPS = {'step2': 2, 'step4': 4, 'step5': 5, 'step8': 8, 'step10': 10, 'step16': 16}
DEFAULT_STEP = 5
# Regel 3: Kommentar-Präfixe, die eine spezielle Behandlung erfordern
COMMENT_PREFIXES = ('//', '/*', '<!--', '-->')

def parse_config_file():
    """
    Liest und verarbeitet die Konfigurationsdatei Gtst.htm und schreibt das Ergebnis
    in eine 1D-Array-Struktur in die Ausgabedatei G2.htm.
    
    Inklusive der Regel für die Behandlung von Kommentarzeilen.
    """
    try:
        with open(INFILE, "r", encoding="utf-8") as f:
            lines = f.readlines()
    except FileNotFoundError:
        print(f"FEHLER: Eingabedatei '{INFILE}' nicht gefunden.")
        return []

    output_array = []
    step = DEFAULT_STEP
    step_is_finalized = False
    last_idx = -1

    # Erstelle ein Regex-Pattern für die Delimiter, um es wiederzuverwenden
    delimiter_class = '[' + re.escape(''.join(DELIMITERS)) + ']'

    if DEBUG: print(f"--- Starte Verarbeitung von {INFILE} mit {len(lines)} Zeilen ---")

    # --- Hauptverarbeitungsschleife ---
    for line_num, original_line in enumerate(lines):
        line = original_line.strip()
        if not line:
            continue

        # --- NEUE REGEL: Ignoriere reine Kommentarzeilen ---
        # Behandle Zeilen mit '//' als Kommentar, AUSSER sie folgen dem Muster:
        # "//<index><delimiter>..."
        if line.startswith('//'):
            # Pattern: Startet mit //, optional Leerraum, dann Ziffern, optional Leerraum, dann Trennzeichen.
            pattern = r'^\/\/\s*\d+\s*' + delimiter_class
            if not re.match(pattern, line):
                if DEBUG:
                    print(f"Zeile {line_num+1}: Ignoriert (reiner Kommentar). Inhalt: '{line}'")
                continue # Zeile ignorieren und mit der nächsten weitermachen
        # --- ENDE NEUE REGEL ---

        # 1. Finde das erste gültige Trennzeichen (innerhalb der ersten 20 Zeichen)
        delimiter, d_pos = None, -1
        match = re.search(delimiter_class, line[:20])
        if match:
            delimiter = match.group(0)
            d_pos = match.start()

        # Ignoriere Zeilen ohne gültiges Trennzeichen am Anfang
        if not delimiter:
            if DEBUG:
                print(f"Zeile {line_num+1}: Übersprungen (kein Trennzeichen gefunden). Inhalt: '{line}'")
            continue

        # 2. Teile die Zeile in "Kopf" (vor Trennzeichen) und "Inhalt"
        head = line[:d_pos]
        content = line[d_pos + 1:]

        # 3. Extrahiere den Index aus dem Kopf
        idx_str = "".join(filter(str.isdigit, head))
        if idx_str:
            idx = int(idx_str)
        else:
            idx = last_idx + 1
            if DEBUG: print(f"Zeile {line_num+1}: Keinen Index gefunden, generiere nächsten Index: {idx}")
        last_idx = idx

        # 4. Erkenne die Step-Größe NUR in der Zeile mit Index 0
        if idx == 0 and not step_is_finalized:
            found_step_in_line = False
            for key, val in VALID_STEPS.items():
                # Suche 'key' in der gesamten Originalzeile, um Fälle wie "0 | step5 | ..." zu erfassen
                if key in original_line:
                    step = val
                    print(f"Info: Step-Größe wurde aus Zeile {line_num+1} auf {step} gesetzt (Schlüsselwort '{key}' gefunden).")
                    found_step_in_line = True
                    break
            
            if not found_step_in_line and DEBUG:
                print(f"Warnung: In Zeile mit Index 0 wurde kein 'stepX' gefunden. Benutze Standard-Step: {step}.")
            step_is_finalized = True

        # 5. Zerlege den Inhalt in Werte
        values = [p.strip() for p in content.split(delimiter)]
        
        # 6. Normalisiere den Werte-Block auf die 'step'-Größe
        if len(values) > step:
            if DEBUG: print(f"Zeile {line_num+1}: Kürze Werte von {len(values)} auf {step}.")
            values = values[:step]
        elif len(values) < step:
            values.extend([''] * (step - len(values)))
        
        # 7. Platziere den Werte-Block im 1D-Ausgabearray
        start_pos = idx * step
        required_size = start_pos + step
        if len(output_array) < required_size:
            output_array.extend([''] * (required_size - len(output_array)))
        output_array[start_pos : start_pos + step] = values

        if DEBUG:
            print(f"Zeile {line_num+1}: Verarbeitet -> Index={idx}, Trennzeichen='{delimiter}', Werte={values} -> Positionen {start_pos}-{start_pos + step - 1}")

    return output_array


def write_output_file(data):
    """Schreibt das 1D-Array in die Zieldatei."""
    if not data:
        print("Warnung: Keine Daten zum Schreiben vorhanden.")
        return
        
    try:
        with open(OUTFILE, "w", encoding="utf-8") as f:
            f.write(f"<!-- Generated by {SCRIPT_NAME} (AI_ID: {AI_ID}) -->\n")
            f.write(f"<!-- Total elements: {len(data)} -->\n")
            for i, value in enumerate(data):
                f.write(f"{i}|{value}\n")
        print(f"\n✓ ERFOLG: {len(data)} Elemente wurden in '{OUTFILE}' geschrieben.")
    except IOError as e:
        print(f"\nFEHLER: Schreiben der Datei '{OUTFILE}' fehlgeschlagen: {e}")


# --- Hauptausführung ---
if __name__ == '__main__':
    print(f"--- Führe {SCRIPT_NAME} aus ---")
    
    # Erstelle die Testdatei, wenn sie nicht existiert
    if not os.path.exists(INFILE):
        print(f"Info: Eingabedatei '{INFILE}' nicht gefunden. Erstelle sie mit Testinhalt.")
        # Hier den Inhalt aus deiner <pre>-Box einfügen
        test_content = """// ---  SAVED CONFIG   ---  0 | step5 | 5 | | | 
// lines mit (1)comment werden nur weiter geparst geprueft wenn : (2)index number direct nach (3)comment AND  dann (4)delimiter   AND  dann (5)key 
// kein index direct nach comment ignore line
// ID | not_valid_line_key     kein index direct nach comment ignore line
// ID   | KEY         | val1   | KEY2   | KEY3  |  KEY4 
// ID   | KEY         | val1   | val2   | val3  |  val4 
0 | step | step5      |  5     |0       |0      |0|0|0|    easy: 0,step ,step5 ,,,,
-->1     | range_user | 31-99  |1       |1      |1  | 1 | <!--      
<!--2    , c_bg       ,#320a2b ,Color    , 2    ,2,2,2,2,2,
-->3     | dbgg       | 1      | c_fg    | #cccccc | Color  | 3  |3 | 3 | 3 | 3  | | | | 5 comment /*
/**/4.      c_btn      .#3e3e42 .Color    . 4    .4.4.4.4.4.4.4.
,key_ohne_index ohne comment, Segoe UI , Font , -   , index 5*5= 25 wird fuer key berechnet 
; 6.key6  .6.6.6.6.6.6.6.6.....
//,key7,,,7,7,,,7,7,7,,,    must ignore , kein index   direct nach comment
  ,key8 , ,8  ,8,8,8,8,,,,    ok index 8*5 fuer key8  wird berechnet
 10 . key_10 . value_key_10   . key_10_2_value_10_2  . key_10_3_value_10_3 .  key_10_4_value_10_4 . "key_10_5_value_10_5   10_5 not used"
"""
        with open(INFILE, "w", encoding="utf-8") as f:
            f.write(test_content)
    
    # Führe die Hauptfunktionen aus
    result_array = parse_config_file()
    write_output_file(result_array)
    
    print(f"--- {SCRIPT_NAME} beendet ---")



#############################################################################################
##-- das ergebnis sieht gut aus nur die beschreibung war nicht zutreffend




 kann noch ein fehler drinn sein?
 
 



